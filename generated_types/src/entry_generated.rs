// automatically generated by the FlatBuffers compiler, do not modify

use std::cmp::Ordering;
use std::mem;

extern crate flatbuffers;
use self::flatbuffers::EndianScalar;

#[allow(unused_imports, dead_code)]
pub mod influxdata {

    use std::cmp::Ordering;
    use std::mem;

    extern crate flatbuffers;
    use self::flatbuffers::EndianScalar;
    #[allow(unused_imports, dead_code)]
    pub mod iox {

        use std::cmp::Ordering;
        use std::mem;

        extern crate flatbuffers;
        use self::flatbuffers::EndianScalar;
        #[allow(unused_imports, dead_code)]
        pub mod write {

            use std::cmp::Ordering;
            use std::mem;

            extern crate flatbuffers;
            use self::flatbuffers::EndianScalar;
            #[allow(unused_imports, dead_code)]
            pub mod v_1 {

                use std::cmp::Ordering;
                use std::mem;

                extern crate flatbuffers;
                use self::flatbuffers::EndianScalar;

                #[deprecated(
                    since = "2.0.0",
                    note = "Use associated constants instead. This will no longer be generated in 2021."
                )]
                pub const ENUM_MIN_COLUMN_VALUE: u8 = 0;
                #[deprecated(
                    since = "2.0.0",
                    note = "Use associated constants instead. This will no longer be generated in 2021."
                )]
                pub const ENUM_MAX_COLUMN_VALUE: u8 = 6;
                #[deprecated(
                    since = "2.0.0",
                    note = "Use associated constants instead. This will no longer be generated in 2021."
                )]
                #[allow(non_camel_case_types)]
                pub const ENUM_VALUES_COLUMN_VALUE: [ColumnValue; 7] = [
                    ColumnValue::NONE,
                    ColumnValue::TagValue,
                    ColumnValue::I64Value,
                    ColumnValue::U64Value,
                    ColumnValue::F64Value,
                    ColumnValue::BoolValue,
                    ColumnValue::StringValue,
                ];

                #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
                #[repr(transparent)]
                pub struct ColumnValue(pub u8);
                #[allow(non_upper_case_globals)]
                impl ColumnValue {
                    pub const NONE: Self = Self(0);
                    pub const TagValue: Self = Self(1);
                    pub const I64Value: Self = Self(2);
                    pub const U64Value: Self = Self(3);
                    pub const F64Value: Self = Self(4);
                    pub const BoolValue: Self = Self(5);
                    pub const StringValue: Self = Self(6);

                    pub const ENUM_MIN: u8 = 0;
                    pub const ENUM_MAX: u8 = 6;
                    pub const ENUM_VALUES: &'static [Self] = &[
                        Self::NONE,
                        Self::TagValue,
                        Self::I64Value,
                        Self::U64Value,
                        Self::F64Value,
                        Self::BoolValue,
                        Self::StringValue,
                    ];
                    /// Returns the variant's name or "" if unknown.
                    pub fn variant_name(self) -> Option<&'static str> {
                        match self {
                            Self::NONE => Some("NONE"),
                            Self::TagValue => Some("TagValue"),
                            Self::I64Value => Some("I64Value"),
                            Self::U64Value => Some("U64Value"),
                            Self::F64Value => Some("F64Value"),
                            Self::BoolValue => Some("BoolValue"),
                            Self::StringValue => Some("StringValue"),
                            _ => None,
                        }
                    }
                }
                impl std::fmt::Debug for ColumnValue {
                    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
                        if let Some(name) = self.variant_name() {
                            f.write_str(name)
                        } else {
                            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                        }
                    }
                }
                impl<'a> flatbuffers::Follow<'a> for ColumnValue {
                    type Inner = Self;
                    #[inline]
                    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
                        Self(b)
                    }
                }

                impl flatbuffers::Push for ColumnValue {
                    type Output = ColumnValue;
                    #[inline]
                    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                        flatbuffers::emplace_scalar::<u8>(dst, self.0);
                    }
                }

                impl flatbuffers::EndianScalar for ColumnValue {
                    #[inline]
                    fn to_little_endian(self) -> Self {
                        let b = u8::to_le(self.0);
                        Self(b)
                    }
                    #[inline]
                    fn from_little_endian(self) -> Self {
                        let b = u8::from_le(self.0);
                        Self(b)
                    }
                }

                impl<'a> flatbuffers::Verifiable for ColumnValue {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        u8::run_verifier(v, pos)
                    }
                }

                impl flatbuffers::SimpleToVerifyInSlice for ColumnValue {}
                pub struct ColumnValueUnionTableOffset {}

                pub enum EntryOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct Entry<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for Entry<'a> {
                    type Inner = Entry<'a>;
                    #[inline]
                    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table { buf, loc },
                        }
                    }
                }

                impl<'a> Entry<'a> {
                    #[inline]
                    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        Entry { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                        args: &'args EntryArgs<'args>,
                    ) -> flatbuffers::WIPOffset<Entry<'bldr>> {
                        let mut builder = EntryBuilder::new(_fbb);
                        if let Some(x) = args.deletes {
                            builder.add_deletes(x);
                        }
                        if let Some(x) = args.writes {
                            builder.add_writes(x);
                        }
                        builder.finish()
                    }

                    pub const VT_WRITES: flatbuffers::VOffsetT = 4;
                    pub const VT_DELETES: flatbuffers::VOffsetT = 6;

                    #[inline]
                    pub fn writes(
                        &self,
                    ) -> Option<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PartitionWrite<'a>>>,
                    > {
                        self._tab.get::<flatbuffers::ForwardsUOffset<
                            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PartitionWrite>>,
                        >>(Entry::VT_WRITES, None)
                    }
                    #[inline]
                    pub fn deletes(
                        &self,
                    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Delete<'a>>>>
                    {
                        self._tab.get::<flatbuffers::ForwardsUOffset<
                            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Delete>>,
                        >>(Entry::VT_DELETES, None)
                    }
                }

                impl flatbuffers::Verifiable for Entry<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
                            .visit_field::<flatbuffers::ForwardsUOffset<
                                flatbuffers::Vector<
                                    '_,
                                    flatbuffers::ForwardsUOffset<PartitionWrite>,
                                >,
                            >>(&"writes", Self::VT_WRITES, false)?
                            .visit_field::<flatbuffers::ForwardsUOffset<
                                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Delete>>,
                            >>(&"deletes", Self::VT_DELETES, false)?
                            .finish();
                        Ok(())
                    }
                }
                pub struct EntryArgs<'a> {
                    pub writes: Option<
                        flatbuffers::WIPOffset<
                            flatbuffers::Vector<
                                'a,
                                flatbuffers::ForwardsUOffset<PartitionWrite<'a>>,
                            >,
                        >,
                    >,
                    pub deletes: Option<
                        flatbuffers::WIPOffset<
                            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Delete<'a>>>,
                        >,
                    >,
                }
                impl<'a> Default for EntryArgs<'a> {
                    #[inline]
                    fn default() -> Self {
                        EntryArgs {
                            writes: None,
                            deletes: None,
                        }
                    }
                }
                pub struct EntryBuilder<'a: 'b, 'b> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b> EntryBuilder<'a, 'b> {
                    #[inline]
                    pub fn add_writes(
                        &mut self,
                        writes: flatbuffers::WIPOffset<
                            flatbuffers::Vector<
                                'b,
                                flatbuffers::ForwardsUOffset<PartitionWrite<'b>>,
                            >,
                        >,
                    ) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            Entry::VT_WRITES,
                            writes,
                        );
                    }
                    #[inline]
                    pub fn add_deletes(
                        &mut self,
                        deletes: flatbuffers::WIPOffset<
                            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Delete<'b>>>,
                        >,
                    ) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            Entry::VT_DELETES,
                            deletes,
                        );
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    ) -> EntryBuilder<'a, 'b> {
                        let start = _fbb.start_table();
                        EntryBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<Entry<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl std::fmt::Debug for Entry<'_> {
                    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        let mut ds = f.debug_struct("Entry");
                        ds.field("writes", &self.writes());
                        ds.field("deletes", &self.deletes());
                        ds.finish()
                    }
                }
                pub enum DeleteOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct Delete<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for Delete<'a> {
                    type Inner = Delete<'a>;
                    #[inline]
                    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table { buf, loc },
                        }
                    }
                }

                impl<'a> Delete<'a> {
                    #[inline]
                    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        Delete { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                        args: &'args DeleteArgs<'args>,
                    ) -> flatbuffers::WIPOffset<Delete<'bldr>> {
                        let mut builder = DeleteBuilder::new(_fbb);
                        if let Some(x) = args.predicate {
                            builder.add_predicate(x);
                        }
                        if let Some(x) = args.table_name {
                            builder.add_table_name(x);
                        }
                        builder.finish()
                    }

                    pub const VT_TABLE_NAME: flatbuffers::VOffsetT = 4;
                    pub const VT_PREDICATE: flatbuffers::VOffsetT = 6;

                    #[inline]
                    pub fn table_name(&self) -> Option<&'a str> {
                        self._tab
                            .get::<flatbuffers::ForwardsUOffset<&str>>(Delete::VT_TABLE_NAME, None)
                    }
                    #[inline]
                    pub fn predicate(&self) -> Option<&'a str> {
                        self._tab
                            .get::<flatbuffers::ForwardsUOffset<&str>>(Delete::VT_PREDICATE, None)
                    }
                }

                impl flatbuffers::Verifiable for Delete<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
                            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                                &"table_name",
                                Self::VT_TABLE_NAME,
                                false,
                            )?
                            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                                &"predicate",
                                Self::VT_PREDICATE,
                                false,
                            )?
                            .finish();
                        Ok(())
                    }
                }
                pub struct DeleteArgs<'a> {
                    pub table_name: Option<flatbuffers::WIPOffset<&'a str>>,
                    pub predicate: Option<flatbuffers::WIPOffset<&'a str>>,
                }
                impl<'a> Default for DeleteArgs<'a> {
                    #[inline]
                    fn default() -> Self {
                        DeleteArgs {
                            table_name: None,
                            predicate: None,
                        }
                    }
                }
                pub struct DeleteBuilder<'a: 'b, 'b> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b> DeleteBuilder<'a, 'b> {
                    #[inline]
                    pub fn add_table_name(&mut self, table_name: flatbuffers::WIPOffset<&'b str>) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            Delete::VT_TABLE_NAME,
                            table_name,
                        );
                    }
                    #[inline]
                    pub fn add_predicate(&mut self, predicate: flatbuffers::WIPOffset<&'b str>) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            Delete::VT_PREDICATE,
                            predicate,
                        );
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    ) -> DeleteBuilder<'a, 'b> {
                        let start = _fbb.start_table();
                        DeleteBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<Delete<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl std::fmt::Debug for Delete<'_> {
                    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        let mut ds = f.debug_struct("Delete");
                        ds.field("table_name", &self.table_name());
                        ds.field("predicate", &self.predicate());
                        ds.finish()
                    }
                }
                pub enum PartitionWriteOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct PartitionWrite<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for PartitionWrite<'a> {
                    type Inner = PartitionWrite<'a>;
                    #[inline]
                    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table { buf, loc },
                        }
                    }
                }

                impl<'a> PartitionWrite<'a> {
                    #[inline]
                    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        PartitionWrite { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                        args: &'args PartitionWriteArgs<'args>,
                    ) -> flatbuffers::WIPOffset<PartitionWrite<'bldr>> {
                        let mut builder = PartitionWriteBuilder::new(_fbb);
                        if let Some(x) = args.table_batches {
                            builder.add_table_batches(x);
                        }
                        if let Some(x) = args.key {
                            builder.add_key(x);
                        }
                        builder.finish()
                    }

                    pub const VT_KEY: flatbuffers::VOffsetT = 4;
                    pub const VT_TABLE_BATCHES: flatbuffers::VOffsetT = 6;

                    #[inline]
                    pub fn key(&self) -> Option<&'a str> {
                        self._tab
                            .get::<flatbuffers::ForwardsUOffset<&str>>(PartitionWrite::VT_KEY, None)
                    }
                    #[inline]
                    pub fn table_batches(
                        &self,
                    ) -> Option<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TableWriteBatch<'a>>>,
                    > {
                        self._tab.get::<flatbuffers::ForwardsUOffset<
                            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TableWriteBatch>>,
                        >>(PartitionWrite::VT_TABLE_BATCHES, None)
                    }
                }

                impl flatbuffers::Verifiable for PartitionWrite<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
                            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                                &"key",
                                Self::VT_KEY,
                                false,
                            )?
                            .visit_field::<flatbuffers::ForwardsUOffset<
                                flatbuffers::Vector<
                                    '_,
                                    flatbuffers::ForwardsUOffset<TableWriteBatch>,
                                >,
                            >>(
                                &"table_batches", Self::VT_TABLE_BATCHES, false
                            )?
                            .finish();
                        Ok(())
                    }
                }
                pub struct PartitionWriteArgs<'a> {
                    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
                    pub table_batches: Option<
                        flatbuffers::WIPOffset<
                            flatbuffers::Vector<
                                'a,
                                flatbuffers::ForwardsUOffset<TableWriteBatch<'a>>,
                            >,
                        >,
                    >,
                }
                impl<'a> Default for PartitionWriteArgs<'a> {
                    #[inline]
                    fn default() -> Self {
                        PartitionWriteArgs {
                            key: None,
                            table_batches: None,
                        }
                    }
                }
                pub struct PartitionWriteBuilder<'a: 'b, 'b> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b> PartitionWriteBuilder<'a, 'b> {
                    #[inline]
                    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            PartitionWrite::VT_KEY,
                            key,
                        );
                    }
                    #[inline]
                    pub fn add_table_batches(
                        &mut self,
                        table_batches: flatbuffers::WIPOffset<
                            flatbuffers::Vector<
                                'b,
                                flatbuffers::ForwardsUOffset<TableWriteBatch<'b>>,
                            >,
                        >,
                    ) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            PartitionWrite::VT_TABLE_BATCHES,
                            table_batches,
                        );
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    ) -> PartitionWriteBuilder<'a, 'b> {
                        let start = _fbb.start_table();
                        PartitionWriteBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<PartitionWrite<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl std::fmt::Debug for PartitionWrite<'_> {
                    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        let mut ds = f.debug_struct("PartitionWrite");
                        ds.field("key", &self.key());
                        ds.field("table_batches", &self.table_batches());
                        ds.finish()
                    }
                }
                pub enum TableWriteBatchOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct TableWriteBatch<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for TableWriteBatch<'a> {
                    type Inner = TableWriteBatch<'a>;
                    #[inline]
                    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table { buf, loc },
                        }
                    }
                }

                impl<'a> TableWriteBatch<'a> {
                    #[inline]
                    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        TableWriteBatch { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                        args: &'args TableWriteBatchArgs<'args>,
                    ) -> flatbuffers::WIPOffset<TableWriteBatch<'bldr>> {
                        let mut builder = TableWriteBatchBuilder::new(_fbb);
                        if let Some(x) = args.rows {
                            builder.add_rows(x);
                        }
                        if let Some(x) = args.column_names {
                            builder.add_column_names(x);
                        }
                        if let Some(x) = args.name {
                            builder.add_name(x);
                        }
                        builder.finish()
                    }

                    pub const VT_NAME: flatbuffers::VOffsetT = 4;
                    pub const VT_COLUMN_NAMES: flatbuffers::VOffsetT = 6;
                    pub const VT_ROWS: flatbuffers::VOffsetT = 8;

                    #[inline]
                    pub fn name(&self) -> Option<&'a str> {
                        self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                            TableWriteBatch::VT_NAME,
                            None,
                        )
                    }
                    #[inline]
                    pub fn column_names(
                        &self,
                    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>
                    {
                        self._tab.get::<flatbuffers::ForwardsUOffset<
                            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
                        >>(TableWriteBatch::VT_COLUMN_NAMES, None)
                    }
                    #[inline]
                    pub fn rows(
                        &self,
                    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Row<'a>>>>
                    {
                        self._tab.get::<flatbuffers::ForwardsUOffset<
                            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Row>>,
                        >>(TableWriteBatch::VT_ROWS, None)
                    }
                }

                impl flatbuffers::Verifiable for TableWriteBatch<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
                            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                                &"name",
                                Self::VT_NAME,
                                false,
                            )?
                            .visit_field::<flatbuffers::ForwardsUOffset<
                                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
                            >>(
                                &"column_names", Self::VT_COLUMN_NAMES, false
                            )?
                            .visit_field::<flatbuffers::ForwardsUOffset<
                                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Row>>,
                            >>(&"rows", Self::VT_ROWS, false)?
                            .finish();
                        Ok(())
                    }
                }
                pub struct TableWriteBatchArgs<'a> {
                    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
                    pub column_names: Option<
                        flatbuffers::WIPOffset<
                            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
                        >,
                    >,
                    pub rows: Option<
                        flatbuffers::WIPOffset<
                            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Row<'a>>>,
                        >,
                    >,
                }
                impl<'a> Default for TableWriteBatchArgs<'a> {
                    #[inline]
                    fn default() -> Self {
                        TableWriteBatchArgs {
                            name: None,
                            column_names: None,
                            rows: None,
                        }
                    }
                }
                pub struct TableWriteBatchBuilder<'a: 'b, 'b> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b> TableWriteBatchBuilder<'a, 'b> {
                    #[inline]
                    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            TableWriteBatch::VT_NAME,
                            name,
                        );
                    }
                    #[inline]
                    pub fn add_column_names(
                        &mut self,
                        column_names: flatbuffers::WIPOffset<
                            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
                        >,
                    ) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            TableWriteBatch::VT_COLUMN_NAMES,
                            column_names,
                        );
                    }
                    #[inline]
                    pub fn add_rows(
                        &mut self,
                        rows: flatbuffers::WIPOffset<
                            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Row<'b>>>,
                        >,
                    ) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            TableWriteBatch::VT_ROWS,
                            rows,
                        );
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    ) -> TableWriteBatchBuilder<'a, 'b> {
                        let start = _fbb.start_table();
                        TableWriteBatchBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<TableWriteBatch<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl std::fmt::Debug for TableWriteBatch<'_> {
                    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        let mut ds = f.debug_struct("TableWriteBatch");
                        ds.field("name", &self.name());
                        ds.field("column_names", &self.column_names());
                        ds.field("rows", &self.rows());
                        ds.finish()
                    }
                }
                pub enum RowOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct Row<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for Row<'a> {
                    type Inner = Row<'a>;
                    #[inline]
                    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table { buf, loc },
                        }
                    }
                }

                impl<'a> Row<'a> {
                    #[inline]
                    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        Row { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                        args: &'args RowArgs<'args>,
                    ) -> flatbuffers::WIPOffset<Row<'bldr>> {
                        let mut builder = RowBuilder::new(_fbb);
                        if let Some(x) = args.values {
                            builder.add_values(x);
                        }
                        builder.finish()
                    }

                    pub const VT_VALUES: flatbuffers::VOffsetT = 4;

                    #[inline]
                    pub fn values(
                        &self,
                    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Value<'a>>>>
                    {
                        self._tab.get::<flatbuffers::ForwardsUOffset<
                            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Value>>,
                        >>(Row::VT_VALUES, None)
                    }
                }

                impl flatbuffers::Verifiable for Row<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
                            .visit_field::<flatbuffers::ForwardsUOffset<
                                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Value>>,
                            >>(&"values", Self::VT_VALUES, false)?
                            .finish();
                        Ok(())
                    }
                }
                pub struct RowArgs<'a> {
                    pub values: Option<
                        flatbuffers::WIPOffset<
                            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Value<'a>>>,
                        >,
                    >,
                }
                impl<'a> Default for RowArgs<'a> {
                    #[inline]
                    fn default() -> Self {
                        RowArgs { values: None }
                    }
                }
                pub struct RowBuilder<'a: 'b, 'b> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b> RowBuilder<'a, 'b> {
                    #[inline]
                    pub fn add_values(
                        &mut self,
                        values: flatbuffers::WIPOffset<
                            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Value<'b>>>,
                        >,
                    ) {
                        self.fbb_
                            .push_slot_always::<flatbuffers::WIPOffset<_>>(Row::VT_VALUES, values);
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    ) -> RowBuilder<'a, 'b> {
                        let start = _fbb.start_table();
                        RowBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<Row<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl std::fmt::Debug for Row<'_> {
                    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        let mut ds = f.debug_struct("Row");
                        ds.field("values", &self.values());
                        ds.finish()
                    }
                }
                pub enum ValueOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct Value<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for Value<'a> {
                    type Inner = Value<'a>;
                    #[inline]
                    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table { buf, loc },
                        }
                    }
                }

                impl<'a> Value<'a> {
                    #[inline]
                    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        Value { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                        args: &'args ValueArgs,
                    ) -> flatbuffers::WIPOffset<Value<'bldr>> {
                        let mut builder = ValueBuilder::new(_fbb);
                        if let Some(x) = args.value {
                            builder.add_value(x);
                        }
                        builder.add_value_type(args.value_type);
                        builder.finish()
                    }

                    pub const VT_VALUE_TYPE: flatbuffers::VOffsetT = 4;
                    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

                    #[inline]
                    pub fn value_type(&self) -> ColumnValue {
                        self._tab
                            .get::<ColumnValue>(Value::VT_VALUE_TYPE, Some(ColumnValue::NONE))
                            .unwrap()
                    }
                    #[inline]
                    pub fn value(&self) -> Option<flatbuffers::Table<'a>> {
                        self._tab
                            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                                Value::VT_VALUE,
                                None,
                            )
                    }
                    #[inline]
                    #[allow(non_snake_case)]
                    pub fn value_as_tag_value(&self) -> Option<TagValue<'a>> {
                        if self.value_type() == ColumnValue::TagValue {
                            self.value().map(TagValue::init_from_table)
                        } else {
                            None
                        }
                    }

                    #[inline]
                    #[allow(non_snake_case)]
                    pub fn value_as_i64value(&self) -> Option<I64Value<'a>> {
                        if self.value_type() == ColumnValue::I64Value {
                            self.value().map(I64Value::init_from_table)
                        } else {
                            None
                        }
                    }

                    #[inline]
                    #[allow(non_snake_case)]
                    pub fn value_as_u64value(&self) -> Option<U64Value<'a>> {
                        if self.value_type() == ColumnValue::U64Value {
                            self.value().map(U64Value::init_from_table)
                        } else {
                            None
                        }
                    }

                    #[inline]
                    #[allow(non_snake_case)]
                    pub fn value_as_f64value(&self) -> Option<F64Value<'a>> {
                        if self.value_type() == ColumnValue::F64Value {
                            self.value().map(F64Value::init_from_table)
                        } else {
                            None
                        }
                    }

                    #[inline]
                    #[allow(non_snake_case)]
                    pub fn value_as_bool_value(&self) -> Option<BoolValue<'a>> {
                        if self.value_type() == ColumnValue::BoolValue {
                            self.value().map(BoolValue::init_from_table)
                        } else {
                            None
                        }
                    }

                    #[inline]
                    #[allow(non_snake_case)]
                    pub fn value_as_string_value(&self) -> Option<StringValue<'a>> {
                        if self.value_type() == ColumnValue::StringValue {
                            self.value().map(StringValue::init_from_table)
                        } else {
                            None
                        }
                    }
                }

                impl flatbuffers::Verifiable for Value<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
     .visit_union::<ColumnValue, _>(&"value_type", Self::VT_VALUE_TYPE, &"value", Self::VT_VALUE, false, |key, v, pos| {
        match key {
          ColumnValue::TagValue => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TagValue>>("ColumnValue::TagValue", pos),
          ColumnValue::I64Value => v.verify_union_variant::<flatbuffers::ForwardsUOffset<I64Value>>("ColumnValue::I64Value", pos),
          ColumnValue::U64Value => v.verify_union_variant::<flatbuffers::ForwardsUOffset<U64Value>>("ColumnValue::U64Value", pos),
          ColumnValue::F64Value => v.verify_union_variant::<flatbuffers::ForwardsUOffset<F64Value>>("ColumnValue::F64Value", pos),
          ColumnValue::BoolValue => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BoolValue>>("ColumnValue::BoolValue", pos),
          ColumnValue::StringValue => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StringValue>>("ColumnValue::StringValue", pos),
          _ => Ok(()),
        }
     })?
     .finish();
                        Ok(())
                    }
                }
                pub struct ValueArgs {
                    pub value_type: ColumnValue,
                    pub value: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
                }
                impl<'a> Default for ValueArgs {
                    #[inline]
                    fn default() -> Self {
                        ValueArgs {
                            value_type: ColumnValue::NONE,
                            value: None,
                        }
                    }
                }
                pub struct ValueBuilder<'a: 'b, 'b> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b> ValueBuilder<'a, 'b> {
                    #[inline]
                    pub fn add_value_type(&mut self, value_type: ColumnValue) {
                        self.fbb_.push_slot::<ColumnValue>(
                            Value::VT_VALUE_TYPE,
                            value_type,
                            ColumnValue::NONE,
                        );
                    }
                    #[inline]
                    pub fn add_value(
                        &mut self,
                        value: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
                    ) {
                        self.fbb_
                            .push_slot_always::<flatbuffers::WIPOffset<_>>(Value::VT_VALUE, value);
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    ) -> ValueBuilder<'a, 'b> {
                        let start = _fbb.start_table();
                        ValueBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<Value<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl std::fmt::Debug for Value<'_> {
                    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        let mut ds = f.debug_struct("Value");
                        ds.field("value_type", &self.value_type());
                        match self.value_type() {
                            ColumnValue::TagValue => {
                                if let Some(x) = self.value_as_tag_value() {
                                    ds.field("value", &x)
                                } else {
                                    ds.field("value", &"InvalidFlatbuffer: Union discriminant does not match value.")
                                }
                            }
                            ColumnValue::I64Value => {
                                if let Some(x) = self.value_as_i64value() {
                                    ds.field("value", &x)
                                } else {
                                    ds.field("value", &"InvalidFlatbuffer: Union discriminant does not match value.")
                                }
                            }
                            ColumnValue::U64Value => {
                                if let Some(x) = self.value_as_u64value() {
                                    ds.field("value", &x)
                                } else {
                                    ds.field("value", &"InvalidFlatbuffer: Union discriminant does not match value.")
                                }
                            }
                            ColumnValue::F64Value => {
                                if let Some(x) = self.value_as_f64value() {
                                    ds.field("value", &x)
                                } else {
                                    ds.field("value", &"InvalidFlatbuffer: Union discriminant does not match value.")
                                }
                            }
                            ColumnValue::BoolValue => {
                                if let Some(x) = self.value_as_bool_value() {
                                    ds.field("value", &x)
                                } else {
                                    ds.field("value", &"InvalidFlatbuffer: Union discriminant does not match value.")
                                }
                            }
                            ColumnValue::StringValue => {
                                if let Some(x) = self.value_as_string_value() {
                                    ds.field("value", &x)
                                } else {
                                    ds.field("value", &"InvalidFlatbuffer: Union discriminant does not match value.")
                                }
                            }
                            _ => {
                                let x: Option<()> = None;
                                ds.field("value", &x)
                            }
                        };
                        ds.finish()
                    }
                }
                pub enum TagValueOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct TagValue<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for TagValue<'a> {
                    type Inner = TagValue<'a>;
                    #[inline]
                    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table { buf, loc },
                        }
                    }
                }

                impl<'a> TagValue<'a> {
                    #[inline]
                    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        TagValue { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                        args: &'args TagValueArgs<'args>,
                    ) -> flatbuffers::WIPOffset<TagValue<'bldr>> {
                        let mut builder = TagValueBuilder::new(_fbb);
                        if let Some(x) = args.value {
                            builder.add_value(x);
                        }
                        builder.finish()
                    }

                    pub const VT_VALUE: flatbuffers::VOffsetT = 4;

                    #[inline]
                    pub fn value(&self) -> Option<&'a str> {
                        self._tab
                            .get::<flatbuffers::ForwardsUOffset<&str>>(TagValue::VT_VALUE, None)
                    }
                }

                impl flatbuffers::Verifiable for TagValue<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
                            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                                &"value",
                                Self::VT_VALUE,
                                false,
                            )?
                            .finish();
                        Ok(())
                    }
                }
                pub struct TagValueArgs<'a> {
                    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
                }
                impl<'a> Default for TagValueArgs<'a> {
                    #[inline]
                    fn default() -> Self {
                        TagValueArgs { value: None }
                    }
                }
                pub struct TagValueBuilder<'a: 'b, 'b> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b> TagValueBuilder<'a, 'b> {
                    #[inline]
                    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b str>) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            TagValue::VT_VALUE,
                            value,
                        );
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    ) -> TagValueBuilder<'a, 'b> {
                        let start = _fbb.start_table();
                        TagValueBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<TagValue<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl std::fmt::Debug for TagValue<'_> {
                    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        let mut ds = f.debug_struct("TagValue");
                        ds.field("value", &self.value());
                        ds.finish()
                    }
                }
                pub enum I64ValueOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct I64Value<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for I64Value<'a> {
                    type Inner = I64Value<'a>;
                    #[inline]
                    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table { buf, loc },
                        }
                    }
                }

                impl<'a> I64Value<'a> {
                    #[inline]
                    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        I64Value { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                        args: &'args I64ValueArgs,
                    ) -> flatbuffers::WIPOffset<I64Value<'bldr>> {
                        let mut builder = I64ValueBuilder::new(_fbb);
                        builder.add_value(args.value);
                        builder.finish()
                    }

                    pub const VT_VALUE: flatbuffers::VOffsetT = 4;

                    #[inline]
                    pub fn value(&self) -> i64 {
                        self._tab.get::<i64>(I64Value::VT_VALUE, Some(0)).unwrap()
                    }
                }

                impl flatbuffers::Verifiable for I64Value<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
                            .visit_field::<i64>(&"value", Self::VT_VALUE, false)?
                            .finish();
                        Ok(())
                    }
                }
                pub struct I64ValueArgs {
                    pub value: i64,
                }
                impl<'a> Default for I64ValueArgs {
                    #[inline]
                    fn default() -> Self {
                        I64ValueArgs { value: 0 }
                    }
                }
                pub struct I64ValueBuilder<'a: 'b, 'b> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b> I64ValueBuilder<'a, 'b> {
                    #[inline]
                    pub fn add_value(&mut self, value: i64) {
                        self.fbb_.push_slot::<i64>(I64Value::VT_VALUE, value, 0);
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    ) -> I64ValueBuilder<'a, 'b> {
                        let start = _fbb.start_table();
                        I64ValueBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<I64Value<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl std::fmt::Debug for I64Value<'_> {
                    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        let mut ds = f.debug_struct("I64Value");
                        ds.field("value", &self.value());
                        ds.finish()
                    }
                }
                pub enum U64ValueOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct U64Value<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for U64Value<'a> {
                    type Inner = U64Value<'a>;
                    #[inline]
                    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table { buf, loc },
                        }
                    }
                }

                impl<'a> U64Value<'a> {
                    #[inline]
                    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        U64Value { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                        args: &'args U64ValueArgs,
                    ) -> flatbuffers::WIPOffset<U64Value<'bldr>> {
                        let mut builder = U64ValueBuilder::new(_fbb);
                        builder.add_value(args.value);
                        builder.finish()
                    }

                    pub const VT_VALUE: flatbuffers::VOffsetT = 4;

                    #[inline]
                    pub fn value(&self) -> u64 {
                        self._tab.get::<u64>(U64Value::VT_VALUE, Some(0)).unwrap()
                    }
                }

                impl flatbuffers::Verifiable for U64Value<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
                            .visit_field::<u64>(&"value", Self::VT_VALUE, false)?
                            .finish();
                        Ok(())
                    }
                }
                pub struct U64ValueArgs {
                    pub value: u64,
                }
                impl<'a> Default for U64ValueArgs {
                    #[inline]
                    fn default() -> Self {
                        U64ValueArgs { value: 0 }
                    }
                }
                pub struct U64ValueBuilder<'a: 'b, 'b> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b> U64ValueBuilder<'a, 'b> {
                    #[inline]
                    pub fn add_value(&mut self, value: u64) {
                        self.fbb_.push_slot::<u64>(U64Value::VT_VALUE, value, 0);
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    ) -> U64ValueBuilder<'a, 'b> {
                        let start = _fbb.start_table();
                        U64ValueBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<U64Value<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl std::fmt::Debug for U64Value<'_> {
                    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        let mut ds = f.debug_struct("U64Value");
                        ds.field("value", &self.value());
                        ds.finish()
                    }
                }
                pub enum F64ValueOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct F64Value<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for F64Value<'a> {
                    type Inner = F64Value<'a>;
                    #[inline]
                    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table { buf, loc },
                        }
                    }
                }

                impl<'a> F64Value<'a> {
                    #[inline]
                    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        F64Value { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                        args: &'args F64ValueArgs,
                    ) -> flatbuffers::WIPOffset<F64Value<'bldr>> {
                        let mut builder = F64ValueBuilder::new(_fbb);
                        builder.add_value(args.value);
                        builder.finish()
                    }

                    pub const VT_VALUE: flatbuffers::VOffsetT = 4;

                    #[inline]
                    pub fn value(&self) -> f64 {
                        self._tab.get::<f64>(F64Value::VT_VALUE, Some(0.0)).unwrap()
                    }
                }

                impl flatbuffers::Verifiable for F64Value<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
                            .visit_field::<f64>(&"value", Self::VT_VALUE, false)?
                            .finish();
                        Ok(())
                    }
                }
                pub struct F64ValueArgs {
                    pub value: f64,
                }
                impl<'a> Default for F64ValueArgs {
                    #[inline]
                    fn default() -> Self {
                        F64ValueArgs { value: 0.0 }
                    }
                }
                pub struct F64ValueBuilder<'a: 'b, 'b> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b> F64ValueBuilder<'a, 'b> {
                    #[inline]
                    pub fn add_value(&mut self, value: f64) {
                        self.fbb_.push_slot::<f64>(F64Value::VT_VALUE, value, 0.0);
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    ) -> F64ValueBuilder<'a, 'b> {
                        let start = _fbb.start_table();
                        F64ValueBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<F64Value<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl std::fmt::Debug for F64Value<'_> {
                    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        let mut ds = f.debug_struct("F64Value");
                        ds.field("value", &self.value());
                        ds.finish()
                    }
                }
                pub enum BoolValueOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct BoolValue<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for BoolValue<'a> {
                    type Inner = BoolValue<'a>;
                    #[inline]
                    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table { buf, loc },
                        }
                    }
                }

                impl<'a> BoolValue<'a> {
                    #[inline]
                    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        BoolValue { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                        args: &'args BoolValueArgs,
                    ) -> flatbuffers::WIPOffset<BoolValue<'bldr>> {
                        let mut builder = BoolValueBuilder::new(_fbb);
                        builder.add_value(args.value);
                        builder.finish()
                    }

                    pub const VT_VALUE: flatbuffers::VOffsetT = 4;

                    #[inline]
                    pub fn value(&self) -> bool {
                        self._tab
                            .get::<bool>(BoolValue::VT_VALUE, Some(false))
                            .unwrap()
                    }
                }

                impl flatbuffers::Verifiable for BoolValue<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
                            .visit_field::<bool>(&"value", Self::VT_VALUE, false)?
                            .finish();
                        Ok(())
                    }
                }
                pub struct BoolValueArgs {
                    pub value: bool,
                }
                impl<'a> Default for BoolValueArgs {
                    #[inline]
                    fn default() -> Self {
                        BoolValueArgs { value: false }
                    }
                }
                pub struct BoolValueBuilder<'a: 'b, 'b> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b> BoolValueBuilder<'a, 'b> {
                    #[inline]
                    pub fn add_value(&mut self, value: bool) {
                        self.fbb_
                            .push_slot::<bool>(BoolValue::VT_VALUE, value, false);
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    ) -> BoolValueBuilder<'a, 'b> {
                        let start = _fbb.start_table();
                        BoolValueBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<BoolValue<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl std::fmt::Debug for BoolValue<'_> {
                    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        let mut ds = f.debug_struct("BoolValue");
                        ds.field("value", &self.value());
                        ds.finish()
                    }
                }
                pub enum StringValueOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct StringValue<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for StringValue<'a> {
                    type Inner = StringValue<'a>;
                    #[inline]
                    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table { buf, loc },
                        }
                    }
                }

                impl<'a> StringValue<'a> {
                    #[inline]
                    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        StringValue { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                        args: &'args StringValueArgs<'args>,
                    ) -> flatbuffers::WIPOffset<StringValue<'bldr>> {
                        let mut builder = StringValueBuilder::new(_fbb);
                        if let Some(x) = args.value {
                            builder.add_value(x);
                        }
                        builder.finish()
                    }

                    pub const VT_VALUE: flatbuffers::VOffsetT = 4;

                    #[inline]
                    pub fn value(&self) -> Option<&'a str> {
                        self._tab
                            .get::<flatbuffers::ForwardsUOffset<&str>>(StringValue::VT_VALUE, None)
                    }
                }

                impl flatbuffers::Verifiable for StringValue<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
                            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                                &"value",
                                Self::VT_VALUE,
                                false,
                            )?
                            .finish();
                        Ok(())
                    }
                }
                pub struct StringValueArgs<'a> {
                    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
                }
                impl<'a> Default for StringValueArgs<'a> {
                    #[inline]
                    fn default() -> Self {
                        StringValueArgs { value: None }
                    }
                }
                pub struct StringValueBuilder<'a: 'b, 'b> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b> StringValueBuilder<'a, 'b> {
                    #[inline]
                    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b str>) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            StringValue::VT_VALUE,
                            value,
                        );
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    ) -> StringValueBuilder<'a, 'b> {
                        let start = _fbb.start_table();
                        StringValueBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<StringValue<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl std::fmt::Debug for StringValue<'_> {
                    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        let mut ds = f.debug_struct("StringValue");
                        ds.field("value", &self.value());
                        ds.finish()
                    }
                }
                pub enum SegmentOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct Segment<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for Segment<'a> {
                    type Inner = Segment<'a>;
                    #[inline]
                    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table { buf, loc },
                        }
                    }
                }

                impl<'a> Segment<'a> {
                    #[inline]
                    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        Segment { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                        args: &'args SegmentArgs<'args>,
                    ) -> flatbuffers::WIPOffset<Segment<'bldr>> {
                        let mut builder = SegmentBuilder::new(_fbb);
                        builder.add_consistency_high_water_clock(args.consistency_high_water_clock);
                        builder.add_id(args.id);
                        if let Some(x) = args.entries {
                            builder.add_entries(x);
                        }
                        builder.add_writer_id(args.writer_id);
                        builder.finish()
                    }

                    pub const VT_ID: flatbuffers::VOffsetT = 4;
                    pub const VT_WRITER_ID: flatbuffers::VOffsetT = 6;
                    pub const VT_CONSISTENCY_HIGH_WATER_CLOCK: flatbuffers::VOffsetT = 8;
                    pub const VT_ENTRIES: flatbuffers::VOffsetT = 10;

                    #[inline]
                    pub fn id(&self) -> u64 {
                        self._tab.get::<u64>(Segment::VT_ID, Some(0)).unwrap()
                    }
                    #[inline]
                    pub fn writer_id(&self) -> u32 {
                        self._tab
                            .get::<u32>(Segment::VT_WRITER_ID, Some(0))
                            .unwrap()
                    }
                    #[inline]
                    pub fn consistency_high_water_clock(&self) -> u64 {
                        self._tab
                            .get::<u64>(Segment::VT_CONSISTENCY_HIGH_WATER_CLOCK, Some(0))
                            .unwrap()
                    }
                    #[inline]
                    pub fn entries(
                        &self,
                    ) -> Option<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SequencedEntry<'a>>>,
                    > {
                        self._tab.get::<flatbuffers::ForwardsUOffset<
                            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SequencedEntry>>,
                        >>(Segment::VT_ENTRIES, None)
                    }
                }

                impl flatbuffers::Verifiable for Segment<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
                            .visit_field::<u64>(&"id", Self::VT_ID, false)?
                            .visit_field::<u32>(&"writer_id", Self::VT_WRITER_ID, false)?
                            .visit_field::<u64>(
                                &"consistency_high_water_clock",
                                Self::VT_CONSISTENCY_HIGH_WATER_CLOCK,
                                false,
                            )?
                            .visit_field::<flatbuffers::ForwardsUOffset<
                                flatbuffers::Vector<
                                    '_,
                                    flatbuffers::ForwardsUOffset<SequencedEntry>,
                                >,
                            >>(&"entries", Self::VT_ENTRIES, false)?
                            .finish();
                        Ok(())
                    }
                }
                pub struct SegmentArgs<'a> {
                    pub id: u64,
                    pub writer_id: u32,
                    pub consistency_high_water_clock: u64,
                    pub entries: Option<
                        flatbuffers::WIPOffset<
                            flatbuffers::Vector<
                                'a,
                                flatbuffers::ForwardsUOffset<SequencedEntry<'a>>,
                            >,
                        >,
                    >,
                }
                impl<'a> Default for SegmentArgs<'a> {
                    #[inline]
                    fn default() -> Self {
                        SegmentArgs {
                            id: 0,
                            writer_id: 0,
                            consistency_high_water_clock: 0,
                            entries: None,
                        }
                    }
                }
                pub struct SegmentBuilder<'a: 'b, 'b> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b> SegmentBuilder<'a, 'b> {
                    #[inline]
                    pub fn add_id(&mut self, id: u64) {
                        self.fbb_.push_slot::<u64>(Segment::VT_ID, id, 0);
                    }
                    #[inline]
                    pub fn add_writer_id(&mut self, writer_id: u32) {
                        self.fbb_
                            .push_slot::<u32>(Segment::VT_WRITER_ID, writer_id, 0);
                    }
                    #[inline]
                    pub fn add_consistency_high_water_clock(
                        &mut self,
                        consistency_high_water_clock: u64,
                    ) {
                        self.fbb_.push_slot::<u64>(
                            Segment::VT_CONSISTENCY_HIGH_WATER_CLOCK,
                            consistency_high_water_clock,
                            0,
                        );
                    }
                    #[inline]
                    pub fn add_entries(
                        &mut self,
                        entries: flatbuffers::WIPOffset<
                            flatbuffers::Vector<
                                'b,
                                flatbuffers::ForwardsUOffset<SequencedEntry<'b>>,
                            >,
                        >,
                    ) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            Segment::VT_ENTRIES,
                            entries,
                        );
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    ) -> SegmentBuilder<'a, 'b> {
                        let start = _fbb.start_table();
                        SegmentBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<Segment<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl std::fmt::Debug for Segment<'_> {
                    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        let mut ds = f.debug_struct("Segment");
                        ds.field("id", &self.id());
                        ds.field("writer_id", &self.writer_id());
                        ds.field(
                            "consistency_high_water_clock",
                            &self.consistency_high_water_clock(),
                        );
                        ds.field("entries", &self.entries());
                        ds.finish()
                    }
                }
                pub enum SequencedEntryOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct SequencedEntry<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for SequencedEntry<'a> {
                    type Inner = SequencedEntry<'a>;
                    #[inline]
                    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table { buf, loc },
                        }
                    }
                }

                impl<'a> SequencedEntry<'a> {
                    #[inline]
                    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        SequencedEntry { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                        args: &'args SequencedEntryArgs<'args>,
                    ) -> flatbuffers::WIPOffset<SequencedEntry<'bldr>> {
                        let mut builder = SequencedEntryBuilder::new(_fbb);
                        builder.add_clock_value(args.clock_value);
                        if let Some(x) = args.entry {
                            builder.add_entry(x);
                        }
                        builder.add_writer_id(args.writer_id);
                        builder.finish()
                    }

                    pub const VT_CLOCK_VALUE: flatbuffers::VOffsetT = 4;
                    pub const VT_WRITER_ID: flatbuffers::VOffsetT = 6;
                    pub const VT_ENTRY: flatbuffers::VOffsetT = 8;

                    #[inline]
                    pub fn clock_value(&self) -> u64 {
                        self._tab
                            .get::<u64>(SequencedEntry::VT_CLOCK_VALUE, Some(0))
                            .unwrap()
                    }
                    #[inline]
                    pub fn writer_id(&self) -> u32 {
                        self._tab
                            .get::<u32>(SequencedEntry::VT_WRITER_ID, Some(0))
                            .unwrap()
                    }
                    #[inline]
                    pub fn entry(&self) -> Option<Entry<'a>> {
                        self._tab.get::<flatbuffers::ForwardsUOffset<Entry>>(
                            SequencedEntry::VT_ENTRY,
                            None,
                        )
                    }
                }

                impl flatbuffers::Verifiable for SequencedEntry<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
                            .visit_field::<u64>(&"clock_value", Self::VT_CLOCK_VALUE, false)?
                            .visit_field::<u32>(&"writer_id", Self::VT_WRITER_ID, false)?
                            .visit_field::<flatbuffers::ForwardsUOffset<Entry>>(
                                &"entry",
                                Self::VT_ENTRY,
                                false,
                            )?
                            .finish();
                        Ok(())
                    }
                }
                pub struct SequencedEntryArgs<'a> {
                    pub clock_value: u64,
                    pub writer_id: u32,
                    pub entry: Option<flatbuffers::WIPOffset<Entry<'a>>>,
                }
                impl<'a> Default for SequencedEntryArgs<'a> {
                    #[inline]
                    fn default() -> Self {
                        SequencedEntryArgs {
                            clock_value: 0,
                            writer_id: 0,
                            entry: None,
                        }
                    }
                }
                pub struct SequencedEntryBuilder<'a: 'b, 'b> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b> SequencedEntryBuilder<'a, 'b> {
                    #[inline]
                    pub fn add_clock_value(&mut self, clock_value: u64) {
                        self.fbb_
                            .push_slot::<u64>(SequencedEntry::VT_CLOCK_VALUE, clock_value, 0);
                    }
                    #[inline]
                    pub fn add_writer_id(&mut self, writer_id: u32) {
                        self.fbb_
                            .push_slot::<u32>(SequencedEntry::VT_WRITER_ID, writer_id, 0);
                    }
                    #[inline]
                    pub fn add_entry(&mut self, entry: flatbuffers::WIPOffset<Entry<'b>>) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Entry>>(
                            SequencedEntry::VT_ENTRY,
                            entry,
                        );
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    ) -> SequencedEntryBuilder<'a, 'b> {
                        let start = _fbb.start_table();
                        SequencedEntryBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<SequencedEntry<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl std::fmt::Debug for SequencedEntry<'_> {
                    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        let mut ds = f.debug_struct("SequencedEntry");
                        ds.field("clock_value", &self.clock_value());
                        ds.field("writer_id", &self.writer_id());
                        ds.field("entry", &self.entry());
                        ds.finish()
                    }
                }
            } // pub mod v1
        } // pub mod write
    } // pub mod iox
} // pub mod influxdata
