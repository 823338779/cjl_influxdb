namespace influxdata.iox.write.v1;

// Every modification to a database is represented as an entry. These can be forwarded
// on to other IOx servers or can be wrapped with a logical clock value and writer id
// for ordering in a buffer or to subscribers. An Entry is what gets sent from the
// routing layer to the write buffer layer. The write buffer layer uses seqenced entries
// to replicate to its peers and to send to downstream subscribers.
//
// Take the example of sharding, where an IOx server is configured to split an
// incoming write into shards and send the write onto other servers. The batch of line protocol
// written in a request will be split up so that each shard with data will have a
// single Entry that will be sent to it. If the server that is doing the
// sharding is not generating partition keys, the key in partition write won't be
// present. It can be generated downstream. Although it's better to have the sharding
// layer generate the partition keys while it's at the job of parsing and validating
// the line protocol. This will save the downstream stateful layers from doing
// extra work.
//
// Even though this entry type has multiple fields (writes, deletes, others), they
// are mutually exclusive. That is an Entry will only ever have one of those fields.
// So you won't have an entry that has writes and deletes.
table Entry {
  // A collection of partition writes. A given partition will have at most one
  // write in this collection.
  writes: [PartitionWrite];
  // A collection of deletes. Each delete targets a single table, with each table
  // having no more than one delete. Deletes can span partitions because they
  // only have a predicate and do not target any specific partition.
  deletes: [Delete];
}

// A delete from a single table with a predicate. Deletes can span partitions since
// they're concerned with data that has already been written. Partitioning is a way
// to split up writes as they land.
table Delete {
  table_name: string;
  predicate: string;
}

// A write to a  partition. If the IOx server creating this PartitionWrite has
// no rules for generating partition keys, the key will be null, representing
// the empty string.
table PartitionWrite {
  key: string;
  table_batches: [TableWriteBatch];
}

// A collection of rows to write to a single table.
table TableWriteBatch {
  name: string;
  column_names: [string];
  // every row should have the same number of elements as column_names
  rows: [Row];
}

// A single row
table Row {
  // the value's position in the array matches the column name position
  values: [Value];
}

union ColumnValue {
  TagValue,
  I64Value,
  U64Value,
  F64Value,
  BoolValue,
  StringValue
}

// A value for a specific column
table Value {
  value: ColumnValue;
}

table TagValue {
  value: string;
}

table I64Value {
  value: int64;
}

table U64Value {
  value: uint64;
}

table F64Value {
  value: float64;
}

table BoolValue {
  value: bool;
}

table StringValue {
  value: string;
}

// The following definitions are for the write buffer and for downstream subscribers to
// the buffer.

// Segment is a collection of Entries. It is the payload of a Write Buffer
// segment file. Because Write Buffer servers can replicate data with peers,
// entries in the collection may come from different writer ids. Entries within
// a segment should be ordered by ascending order by the clock value then writer id.
table Segment {
  // the segment number
  id: uint64;
  // the writer id of the server that persisted this segment
  writer_id: uint32;
  // this is the clock value that the writer has verified with its peers that
  // entries are ordered and consistent up to. If the writer has no peers this
  // value will just be the clock value for the last sequenced entry in this segment.
  // This value could be lower than the first clock value in the segment if a
  // consistency check has not occured since this segment was started. Or, if
  // a consistency check has occured in a segment following this one, but before
  // this segment has been persisted, the clock value could be higher than the last
  // entry in the segment. This latter condition indicates that all entries in the
  // segment are properly ordered and consistent with other write buffer peers.
  consistency_high_water_clock: uint64;
  // the raw entry data along with their sequence numbers
  entries: [SequencedEntry];
}

// SequencedEntry are what get inserted into a Write Buffer. These are
// what Write Buffer servers replicate to their peers and what go out to
// downstream subscribers of the Buffer. The clock values can be used to order
// the entries from a Buffer server. They are guaranteed to never go backwards.
table SequencedEntry {
  clock_value: uint64;
  writer_id: uint32;
  entry: Entry;
}
